---
title: "[CTF] Imaginary 2025"
date: 2025-09-08 00:00:00 +0800
categories: [CTF, Web]
tags: [test, test]
toc: true
image: assets/img/posts/Imaginary CTF 2025/Miniature.png
---

Le **Imaginary CTF de 2025** était mon premier CTF. J’ai pu y participer le temps d’une matinée et réussir à **flag mes premiers challenges**, deux challenges **Web**.

- Le **premier challenge** reposait sur une mauvaise utilisation de **bcrypt**.
- Le **deuxième challenge** exploitait une faille dans un **algorithme maison de génération de hash** utilisé pour construire le flag.

---

# Premier Challenge / Passwordless

Pour ce challenge nous avons :

- Un lien vers un site web
- Le code source du site
- Une description :
  > _« Je n’ai pas eu le temps d’implémenter la fonctionnalité d’envoi d’e-mails, mais ce n’est pas grave, le site est sécurisé à 100 % tant que personne ne connaît le mot de passe pour se connecter ! »_

<img src="assets/img/posts/Imaginary CTF 2025/passwordless/Login_Page.png" alt="Login page">

<img src="/assets/img/posts/Imaginary CTF 2025/passwordless/Register.png" alt="Formulaire d'inscription du challenge">


En inspectant le code source, on peut trouver ces lignes :

```javascript
const initialPassword = req.body.email + crypto.randomBytes(16).toString("hex");
bcrypt.hash(initialPassword, 10, function (err, hash) {
  if (err) return next(err);
});
```

### Le mot de passe généré est :

- L’email choisi à l’inscription
- Suivi de **32 caractères hexadécimaux aléatoires**
- Puis ce mot de passe est hashé avec **bcrypt**

### Faille

Bcrypt n’utilise que les **72 premiers octets** du mot de passe.  
Tout ce qui dépasse est **ignoré**.

### Exploit

S’inscrire avec un **email volontairement très long** (≥ 72 caractères)  
Se connecter en utilisant comme mot de passe **les 72 premiers caractères** de l’email utilisé à l’inscription

---

# Deuxieme Challenge / Certificate

Pour ce challenge nous avons :

- Un lien vers un site web
- - Une description :
    > _« En guise de remerciement pour votre participation à notre CTF, nous distribuons des certificats de participation !
    > Chacun contient un flag personnalisé, mais je parie que vous n’arriverez pas à obtenir le flag appartenant à Eth007 ! »_

<img src="assets/img/posts/Imaginary CTF 2025/certificate/redacted.png" alt="Redacted">

### Ce qui se passe

Le site génère un certificat avec un **flag calculé côté client** à partir du **nom du participant** trouvable en inspectant le code HTML.

Quand on met **Eth007** comme nom, l’interface remplace l’affichage par **REDACTED**, donc le flag affiché est celui de `REDACTED` et non Eth007.

Dans le **JavaScript**, on trouve :

```js
function customHash(str) {
  let h = 1337;
  for (let i = 0; i < str.length; i++) {
    h = (h * 31 + str.charCodeAt(i)) ^ (h >>> 7);
    h = h >>> 0; // force unsigned
  }
  return h.toString(16);
}

function makeFlag(name) {
  const clean = name.trim() || "anon";
  const h = customHash(clean);
  return `ictf{${h}}`;
}
```

---

### Exploit

On réutilise la même fonction localement avec l’entrée **"Eth007"** :

```js
function customHash(str) {
  let h = 1337;
  for (let i = 0; i < str.length; i++) {
    h = (h * 31 + str.charCodeAt(i)) ^ (h >>> 7);
    h = h >>> 0;
  }
  return h.toString(16);
}

function makeFlag(name) {
  const clean = (name || "").trim() || "anon";
  const h = customHash(clean);
  return `ictf{${h}}`;
}

makeFlag("Eth007");
```

Résultat :
ictf{7b4b3965}
